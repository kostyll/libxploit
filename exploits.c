
#include "exploits.h"
#include "payloads.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// collection of available exploits
struct exploit exploits[EXPLOITS_NUMBER];

int exploitsInit()
{
    exploits[0] = dummy; 
    exploits[1] = vmwareMountSuid; 
    exploits[2] = setuidNmap; 
    exploits[3] = execAwstats; 
    exploits[4] = fdiscWebmin; 

    return 0;
}

struct Xploit *xploitUseExploit(char *name)
{
    int id, i;
    struct exploitParam *param;
    struct exploitParam *currentParam;

    // init libxploit if not yet initialized
    if(strncmp(exploits[0].name, "dummy", sizeof("dummy")) != 0) {
    	if(xploitInitialize(0) == -1) {
            exploitErrCode = XPLOIT_INIT_ERROR;
            return NULL;
    	}
    }

    // check if exploit exists
    if((id = xploitGetExploitID(name)) == -1) {
        exploitErrCode = XPLOIT_UNRECOGNIZED_EXPLOIT_ERROR;
        // set library error
        return NULL;
    }

    // prepare Xploit structure
    struct Xploit *xp = (struct Xploit *)malloc(sizeof(struct Xploit));
	if(xp == NULL)
		return NULL;

    xp->currentExploit = (struct exploit *)malloc(sizeof(struct exploit));
	if(xp->currentExploit == NULL) {
        free(xp);
		return NULL;
    }

    xp->currentPayload = NULL;

    // select exploit
    xp->currentExploit->id = id;
    strncpy(xp->currentExploit->name, exploits[id].name, EXPLOIT_NAME_LENGTH);
    xp->currentExploit->func = exploits[id].func; 
    xp->currentExploit->help = exploits[id].help; 
    xp->currentExploit->paramsNum = exploits[id].paramsNum; 

    // init params
    if(exploits[id].paramsNum > 0) {
        xp->currentExploit->params = (struct exploitParam *)malloc(exploits[id].paramsNum * sizeof(struct exploitParam));
        if(xp->currentExploit->params == NULL) {
            // set library error: out of memory
            free(xp->currentExploit);
            free(xp);
            return NULL;
        }

        // init params
        for(i=0; i < exploits[id].paramsNum; ++i) {
            param = &exploits[id].params[i];
            currentParam = &xp->currentExploit->params[i];
            strncpy(currentParam->name, param->name, PAYLOAD_NAME_LENGTH);
            currentParam->required = param->required;
            currentParam->type = param->type;

            // set default values for opts if any
            if(param->value != NOT_SET && currentParam->type == INTEGER)
                currentParam->value = param->value;
            else
                currentParam->value = NOT_SET;

            if(param->strValueLen > 0 && currentParam->type == STRING) {
                currentParam->strValueLen = param->strValueLen;
                currentParam->strValue = (char *)malloc(currentParam->strValueLen + 1);
                if(currentParam->strValue != NULL) {
                    strncpy(currentParam->strValue, param->strValue, currentParam->strValueLen + 1);
                }
                else {
                    // param could not be initialized: do not set it
                    currentParam->strValue = NULL;
                    currentParam->strValueLen = NOT_SET;
                }
            }
            else {
                currentParam->strValue = NULL;
                currentParam->strValueLen = NOT_SET;
            }
        }
    }

    return xp;
}

void xploitReleaseExploit(struct Xploit *xp)
{
    // TODO: release exploitParams
    if(xp->currentExploit)
		free(xp->currentExploit);
	if(xp->currentPayload)
		free(xp->currentPayload);

	free(xp);
}

void xploitShowExploits()
{
    int i;

    printf("\n");
    for(i=0; i<EXPLOITS_NUMBER; ++i) {
        if(exploits[i].help) {
            exploits[i].help();
            printf("Exploit name: %s\n", exploits[i].name);
            printf("\n");
        }
    }
}

// TODO: change name & make static
int xploitGetExploitID(char *name)
{
    int i;

    if(!name) {
        return -1;
    }

    for(i=0; i<EXPLOITS_NUMBER; ++i) {
        if(strncmp(name, exploits[i].name, EXPLOIT_NAME_LENGTH) == 0) {
            return exploits[i].id;
        }
    }

    //TODO: return XPLOIT_ERROR;
    return -1;
}

static void showExploitOpts(int id)
{
    struct exploitParam *param;
    int i;
    int fieldLenSetting = 0;
    int fieldLenName = 0;

    // find longest default setting
    for(i=0; i<exploits[id].paramsNum; ++i) {
        param = &exploits[id].params[i];
        if(param->strValueLen > fieldLenSetting)
            fieldLenSetting = param->strValueLen;

        if(strlen(param->name) > fieldLenName)
            fieldLenName = strlen(param->name);
    }

    if(fieldLenName < strlen("Name"))
       fieldLenName = strlen("Name");

    if(fieldLenSetting < strlen("Default setting"))
       fieldLenSetting = strlen("Default setting");

    printf("\nExploit options:\n\n");

    printf("%-*s  %-*s  %s\n", fieldLenName, "Name", fieldLenSetting, "Default setting", "Required");
    printf("%-*s  %-*s  %s\n", fieldLenName, "----", fieldLenSetting, "---------------", "--------");

    for(i=0; i<exploits[id].paramsNum; ++i) {
        param = &exploits[id].params[i];
        if(param->required != INTERNAL) {
            param = &exploits[id].params[i];

            printf("%-*s  %-*s  %s\n", fieldLenName, param->name, fieldLenSetting, 
                param->strValueLen ? param->strValue : "",
                param->required == REQUIRED ? "yes" : "no"
            );
        }
    }

}

static void showExploitDetails(int id)
{
    if(exploits[id].det->exploitType == REMOTE)
        printf("Type: remote\n");
    else
        printf("Type: local\n");
}

void xploitShowExploitHelp(char *name)
{
    int id;

    id = xploitGetExploitID(name);
    if(id == -1) {
        printf("no such exploit\n");
        return;
    }

    if(exploits[id].help)
        exploits[id].help();
    if(exploits[id].det)
        showExploitDetails(id);
    showExploitOpts(id);
}

int checkReqExploitOpts(struct exploit *e)
{
    int i;
    struct exploitParam *param;

    if(!e)
        return -1;

    // check if REQUIRED options are set
    for(i=0; i<e->paramsNum; ++i) {
        param = &e->params[i];
        if(param->required == REQUIRED) {
            // check if set
            if(param->type == STRING && (param->strValue == NULL || param->strValueLen == NOT_SET)) {
                // set library error: required payload option ... not set
                fprintf(stderr, "param: '%s' not set\n", param->name);
                return -1;
            }
            else if(param->type == INTEGER && param->value == NOT_SET) {
                // set library error: required payload option ... not set
                fprintf(stderr, "param: '%s' not set\n", param->name);
                return -1;
            }
        }
    }

    return 0;
}

int xploitRunExploit(struct Xploit *xp)
{
    if(!xp) {
        //TODO: report library error: bad Xploit context
        return -1;
    }
    if(!xp->currentExploit) {
        //TODO: report library error: exploit not chosen
        return -1;
    }
    if(!xp->currentPayload) {
        //TODO: report library error: payload not chosen
        return -1;
    }

    // check if all required exploit options are set
    if(checkReqExploitOpts(xp->currentExploit) == -1) {
        return -1;
    }
    
    // check if all required payload options are set
    if(checkReqPayloadOpts(xp->currentPayload) == -1) {
        return -1;
    }
    
    // call initOptionsfunc (calculates internal params) for payload
    // TODO: rewrtie initOptionsfunc for payloads/exec.c
    if(xp->currentPayload->initOptionsfunc != NULL)
        xp->currentPayload->initOptionsfunc(xp);

    // construct final payload
    constructPayload(xp);
    
    // run exploit
    xp->currentExploit->func(xp, xp->currentPayload->data, xp->currentPayload->len);

    return 0;
}

// TODO: for now it doesn't support integer params (e.g, port number). To support it create array for it (like in payloads/exec.c) and then call setInternalPayloadOpt
// TODO: disallow to set INTERNAL params
int xploitSetExploitOpt(struct Xploit *xp, char *paramName, void *newValue)
{
    unsigned int newValueLen = strlen(newValue);
    struct exploitParam *param;
    int i;
    int found = 0;

    if((char *)newValue == NULL)
        return -1;

    if((unsigned int)newValue == 0)
        return -1;

    if((unsigned int)newValueLen == 0)
        return -1;

    for(i=0; i < xp->currentExploit->paramsNum && !found; ++i) {
        param = &xp->currentExploit->params[i];
        if(strcmp(param->name, paramName) == 0) {
            if(param->type == STRING) {

                // free old content if any
                if(param->strValue != NULL) {
                    free(param->strValue);
                    param->strValueLen = 0;
                }

                // prepare new content
                param->strValue = (char *)malloc(newValueLen + 1);
                if(param->strValue == NULL)
                    return -1;

                memcpy(param->strValue, newValue, newValueLen);
                param->strValueLen = newValueLen;
                param->strValue[param->strValueLen] = '\0';
            }
            else if(param->type == INTEGER) {
                param->value = (unsigned int)newValue;
            }

            // done, param found and set
            found = 1;
        }
    }

    if(!found) {
        //library error: unrecognized param for chosen exploit
        printf("unrecognized exploit option: %s\n", paramName);
        return -1;
    }

    return 0;
}
